#panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = "black"),
plot.background = element_blank()
)+
coord_equal(xlim = xlims, ylim = ylims)
G
labelsbreaks
G <- ggplot(predicted, aes(x=x, y=y)) + geom_raster(aes(fill= mean)) +
scale_fill_gradient(trans = 'sqrt', low = "blue", high = "red",
breaks=c(seq(min(predicted$mean),
max(predicted$mean),
ceiling(max(predicted$mean)/5)),max(predicted$mean)),
labels=labelsbreaks,
name=expression(Density~(Ind/km^{"2"}))) +
# scale_fill_gradient(low = "blue", high = "red",name="Density [Ind/sq. km]")+
# scale_fill_viridis(name = "Intensity") +
scale_x_continuous(breaks=seq(425,525,25),label=seq(4.25,5.25,.25))+
scale_y_continuous(breaks=seq(6380,6440,20),label=seq(6.38,6.44,.02))+
xlab(expression(X(meters~x~10^{"6"})))+
ylab(expression(Y(meters~x~10^{"7"})))+
ggtitle(plot.title)+
theme_gdocs()+
theme(
#panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = "black"),
plot.background = element_blank()
)+
coord_equal(xlim = xlims, ylim = ylims)
G
labelsbreaks<-c(seq(min(predicted$mean),
max(predicted$mean),
ceiling(max(predicted$mean)/4)),max(predicted$mean))
labelsbreaks <- round(labelsbreaks,round.scale)
G <- ggplot(predicted, aes(x=x, y=y)) + geom_raster(aes(fill= mean)) +
scale_fill_gradient(trans = 'sqrt', low = "blue", high = "red",
breaks=c(seq(min(predicted$mean),
max(predicted$mean),
ceiling(max(predicted$mean)/4)),max(predicted$mean)),
labels=labelsbreaks,
name=expression(Density~(Ind/km^{"2"}))) +
# scale_fill_gradient(low = "blue", high = "red",name="Density [Ind/sq. km]")+
# scale_fill_viridis(name = "Intensity") +
scale_x_continuous(breaks=seq(425,525,25),label=seq(4.25,5.25,.25))+
scale_y_continuous(breaks=seq(6380,6440,20),label=seq(6.38,6.44,.02))+
xlab(expression(X(meters~x~10^{"6"})))+
ylab(expression(Y(meters~x~10^{"7"})))+
ggtitle(plot.title)+
theme_gdocs()+
theme(
#panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = "black"),
plot.background = element_blank()
)+
coord_equal(xlim = xlims, ylim = ylims)
G
quantile(predicted$mean,c(0.25,0.5,0.75))
labelsbreaks<-c(seq(min(predicted$mean),
max(predicted$mean),
ceiling(max(predicted$mean)/3)),max(predicted$mean))
plot.abundance <- function(predicted,track,plot.title="",plot.boundary=F,
plot.coastline=F,round.scale=0){
labelsbreaks<-c(seq(min(predicted$mean),
max(predicted$mean),
ceiling(max(predicted$mean)/3)),max(predicted$mean))
labelsbreaks <- round(labelsbreaks,round.scale)
transdf <- data.frame(coordinates(track))
xlims <- c(min(transdf$coords.x1)*0.99, max(transdf$coords.x1)*1.01)
ylims <- c(min(transdf$coords.x2)*0.999, max(transdf$coords.x2)*1.001)
G <- ggplot(predicted, aes(x=x, y=y)) + geom_raster(aes(fill= mean)) +
scale_fill_gradient(trans = 'sqrt', low = "blue", high = "red",
breaks=c(seq(min(predicted$mean),
max(predicted$mean),
ceiling(max(predicted$mean)/3)),max(predicted$mean)),
labels=labelsbreaks,
name=expression(Density~(Ind/km^{"2"}))) +
# scale_fill_gradient(low = "blue", high = "red",name="Density [Ind/sq. km]")+
# scale_fill_viridis(name = "Intensity") +
scale_x_continuous(breaks=seq(425,525,25),label=seq(4.25,5.25,.25))+
scale_y_continuous(breaks=seq(6380,6440,20),label=seq(6.38,6.44,.02))+
xlab(expression(X(meters~x~10^{"6"})))+
ylab(expression(Y(meters~x~10^{"7"})))+
ggtitle(plot.title)+
theme_gdocs()+
theme(
#panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = "black"),
plot.background = element_blank()
)+
coord_equal(xlim = xlims, ylim = ylims)
if(plot.coastline==TRUE){
print("loading high resolution coastline.. this may take a moment..")
load(file = 'D:/GIS_DATA/UK_coastline.rda')
coastline_sp_utm <- spTransform(tt, UTM30)
coastData_DF <- fortify(coastline_sp_utm)
G <- G +
geom_polygon(aes(x = long, y = lat, group = group), data = coastData_DF, fill = "darkolivegreen3",
col = "grey35", alpha = 0.7)
}
if(plot.boundary==TRUE){
boundary.shape <- readOGR(dsn="./Data/Shapefile/Moray_Firth_Area_WGS84.shp",
layer="Moray_Firth_Area_WGS84")
boundaryUTM30 <- spTransform(boundary.shape,UTM30)
boundary_DF <- fortify(boundaryUTM30)
G <- G +
geom_polygon(aes(x=long,y=lat,group=group),data=boundary_DF,
col="black",alpha=0)
}
return(G)
}
P <- plot.abundance(model.summaryout,data.loaded$track,plot.title = "test",
plot.boundary = T)
P
plot.abundance <- function(predicted,track,plot.title="",plot.boundary=F,
plot.coastline=F,round.scale=0){
breaks<-c(seq(min(predicted$mean),
max(predicted$mean),
ceiling(max(predicted$mean)/3)),max(predicted$mean))
labels <- round(breaks,round.scale)
transdf <- data.frame(coordinates(track))
xlims <- c(min(transdf$coords.x1)*0.99, max(transdf$coords.x1)*1.01)
ylims <- c(min(transdf$coords.x2)*0.999, max(transdf$coords.x2)*1.001)
G <- ggplot(predicted, aes(x=x, y=y)) + geom_raster(aes(fill= mean)) +
scale_fill_gradient(trans = 'sqrt', low = "blue", high = "red",
breaks=breaks,
labels=labels,
name=expression(Density~(Ind/km^{"2"}))) +
scale_x_continuous(breaks=seq(425,525,25),label=seq(4.25,5.25,.25))+
scale_y_continuous(breaks=seq(6380,6440,20),label=seq(6.38,6.44,.02))+
xlab(expression(X(meters~x~10^{"6"})))+
ylab(expression(Y(meters~x~10^{"7"})))+
ggtitle(plot.title)+
theme_gdocs()+
theme(
#panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = "black"),
plot.background = element_blank()
)+
coord_equal(xlim = xlims, ylim = ylims)
if(plot.coastline==TRUE){
print("loading high resolution coastline.. this may take a moment..")
load(file = 'D:/GIS_DATA/UK_coastline.rda')
coastline_sp_utm <- spTransform(tt, UTM30)
coastData_DF <- fortify(coastline_sp_utm)
G <- G +
geom_polygon(aes(x = long, y = lat, group = group), data = coastData_DF, fill = "darkolivegreen3",
col = "grey35", alpha = 0.7)
}
if(plot.boundary==TRUE){
boundary.shape <- readOGR(dsn="./Data/Shapefile/Moray_Firth_Area_WGS84.shp",
layer="Moray_Firth_Area_WGS84")
boundaryUTM30 <- spTransform(boundary.shape,UTM30)
boundary_DF <- fortify(boundaryUTM30)
G <- G +
geom_polygon(aes(x=long,y=lat,group=group),data=boundary_DF,
col="black",alpha=0)
}
return(G)
}
P <- plot.abundance(model.summaryout,data.loaded$track,plot.title = "test",
plot.boundary = T)
P
# check range
# this is the posterior calculated by the model for the range
# (that we very roughly estimated for the non-informative prior)
int.plot <- plot(lgcp.fit, "Intercept")
# check range
# this is the posterior calculated by the model for the range
# (that we very roughly estimated for the non-informative prior)
int.plot <- plot(lcpe.model, "Intercept")
spde.range <- spde.posterior(lcpe.model, "spatial_spde", what = "range")
plot(spde.range)
plot.pop.priors <- function(pred.list){
predicted<-pred.list$predicted
abund<-pred.list$abund
marginals<-pred.list$marginals
marg.mean<-pred.list$marg.mean
lower.lim <- marginals[1] - 1000  # adjust later
upper.lim <- marginals[3] + 1000  # adjust later
#plot posterior mean and IC
G <- ggplot(data = abund, aes(x = N, y = mean)) +
geom_area(fill="orange") +
geom_vline(xintercept=marginals[1], linetype="dashed", color = "blue") +
geom_vline(xintercept=marginals[2], color = "red") +
geom_vline(xintercept=marginals[3], linetype="dashed", color = "blue") +
ggtitle("Estimated number of Individuals") +
theme_classic(base_size = 16) +
xlim(lower.lim, upper.lim)
# check range
# this is the posterior calculated by the model for the range
# (that we very roughly estimated for the non-informative prior)
int.plot <- plot(lgcp.fit, "Intercept")
spde.range <- spde.posterior(lgcp.fit, "spatial_spde", what = "range")
plot(spde.range)
return(G)
}
source('D:/PROJECTS_CURRENT/SNH_Moray_Firth/SNH_Moray_Firth/scripts/helpers.R')
plot.pop.priors <- function(pred.list){
predicted<-pred.list$predicted
abund<-pred.list$abund
marginals<-pred.list$marginals
marg.mean<-pred.list$marg.mean
lower.lim <- marginals[1] - 1000  # adjust later
upper.lim <- marginals[3] + 1000  # adjust later
#plot posterior mean and IC
G <- ggplot(data = abund, aes(x = N, y = mean)) +
geom_area(fill="orange") +
geom_vline(xintercept=marginals[1], linetype="dashed", color = "blue") +
geom_vline(xintercept=marginals[2], color = "red") +
geom_vline(xintercept=marginals[3], linetype="dashed", color = "blue") +
ggtitle("Estimated number of Individuals") +
theme_classic(base_size = 16) +
xlim(lower.lim, upper.lim)
# check range
# this is the posterior calculated by the model for the range
# (that we very roughly estimated for the non-informative prior)
#int.plot <- plot(lgcp.fit, "Intercept")
#spde.range <- spde.posterior(lgcp.fit, "spatial_spde", what = "range")
#plot(spde.range)
return(G)
}
P2 <- plot.pop.priors(model.summaryout)
model.summaryout <- model.predictions(MESH,lcpe.model)
P2 <- plot.pop.priors(model.summaryout)
P2
plot.pop.priors <- function(pred.list){
predicted<-pred.list$predicted
abund<-pred.list$abund
marginals<-pred.list$marginals
marg.mean<-pred.list$marg.mean
lower.lim <- marginals[1] - 1000  # adjust later
upper.lim <- marginals[3] + 1000  # adjust later
#plot posterior mean and IC
G <- ggplot(data = abund, aes(x = N, y = mean)) +
geom_area(fill="orange",color="black") +
geom_vline(xintercept=marginals[1], linetype="dashed", color = "blue") +
geom_vline(xintercept=marginals[2], color = "red") +
geom_vline(xintercept=marginals[3], linetype="dashed", color = "blue") +
ggtitle("Estimated number of Individuals") +
ylim(expand(c(0,0)))+
theme_gdocs()+
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = "black"),
plot.background = element_blank()
)+
#theme_classic(base_size = 16) +
xlim(lower.lim, upper.lim)
# check range
# this is the posterior calculated by the model for the range
# (that we very roughly estimated for the non-informative prior)
#int.plot <- plot(lgcp.fit, "Intercept")
#spde.range <- spde.posterior(lgcp.fit, "spatial_spde", what = "range")
#plot(spde.range)
return(G)
}
plot.pop.priors(model.summaryout)
#plot posterior mean and IC
G <- ggplot(data = abund, aes(x = N, y = mean)) +
geom_area(fill="orange",color="black") +
geom_vline(xintercept=marginals[1], linetype="dashed", color = "blue") +
geom_vline(xintercept=marginals[2], color = "red") +
geom_vline(xintercept=marginals[3], linetype="dashed", color = "blue") +
ggtitle("Estimated number of Individuals") +
ylim(expand=c(0,0))+
theme_gdocs()+
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = "black"),
plot.background = element_blank()
)+
#theme_classic(base_size = 16) +
xlim(lower.lim, upper.lim)
plot.pop.priors <- function(pred.list){
predicted<-pred.list$predicted
abund<-pred.list$abund
marginals<-pred.list$marginals
marg.mean<-pred.list$marg.mean
lower.lim <- marginals[1] - 1000  # adjust later
upper.lim <- marginals[3] + 1000  # adjust later
#plot posterior mean and IC
G <- ggplot(data = abund, aes(x = N, y = mean)) +
geom_area(fill="orange",color="black") +
geom_vline(xintercept=marginals[1], linetype="dashed", color = "blue") +
geom_vline(xintercept=marginals[2], color = "red") +
geom_vline(xintercept=marginals[3], linetype="dashed", color = "blue") +
ggtitle("Estimated number of Individuals") +
ylim(expand=c(0,0))+
theme_gdocs()+
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = "black"),
plot.background = element_blank()
)+
#theme_classic(base_size = 16) +
xlim(lower.lim, upper.lim)
# check range
# this is the posterior calculated by the model for the range
# (that we very roughly estimated for the non-informative prior)
#int.plot <- plot(lgcp.fit, "Intercept")
#spde.range <- spde.posterior(lgcp.fit, "spatial_spde", what = "range")
#plot(spde.range)
return(G)
}
#plot posterior mean and IC
G <- ggplot(data = abund, aes(x = N, y = mean)) +
geom_area(fill="orange",color="black") +
geom_vline(xintercept=marginals[1], linetype="dashed", color = "blue") +
geom_vline(xintercept=marginals[2], color = "red") +
geom_vline(xintercept=marginals[3], linetype="dashed", color = "blue") +
ggtitle("Estimated number of Individuals") +
ylim(expand=c(0,0))+
theme_gdocs()+
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = "black"),
plot.background = element_blank()
)+
#theme_classic(base_size = 16) +
xlim(lower.lim, upper.lim)
plot.pop.priors(model.summaryout)
plot.pop.priors <- function(pred.list){
predicted<-pred.list$predicted
abund<-pred.list$abund
marginals<-pred.list$marginals
marg.mean<-pred.list$marg.mean
lower.lim <- marginals[1] - 1000  # adjust later
upper.lim <- marginals[3] + 1000  # adjust later
#plot posterior mean and IC
G <- ggplot(data = abund, aes(x = N, y = mean)) +
geom_area(fill="orange",color="black") +
geom_vline(xintercept=marginals[1], linetype="dashed", color = "blue") +
geom_vline(xintercept=marginals[2], color = "red") +
geom_vline(xintercept=marginals[3], linetype="dashed", color = "blue") +
ggtitle("Estimated number of Individuals") +
#ylim(expand=c(0,0))+
theme_gdocs()+
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = "black"),
plot.background = element_blank()
)+
#theme_classic(base_size = 16) +
xlim(lower.lim, upper.lim)
# check range
# this is the posterior calculated by the model for the range
# (that we very roughly estimated for the non-informative prior)
#int.plot <- plot(lgcp.fit, "Intercept")
#spde.range <- spde.posterior(lgcp.fit, "spatial_spde", what = "range")
#plot(spde.range)
return(G)
}
plot.pop.priors(model.summaryout)
#plot posterior mean and IC
G <- ggplot(data = abund, aes(x = N, y = mean)) +
geom_area(fill="orange",color="black") +
geom_vline(xintercept=marginals[1], linetype="dashed", color = "blue") +
geom_vline(xintercept=marginals[2], color = "red") +
geom_vline(xintercept=marginals[3], linetype="dashed", color = "blue") +
ggtitle("Estimated number of Individuals") +
scale_y_continuous(expand=c(0,0))+
theme_gdocs()+
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = "black"),
plot.background = element_blank()
)+
#theme_classic(base_size = 16) +
xlim(lower.lim, upper.lim)
plot.pop.priors <- function(pred.list){
predicted<-pred.list$predicted
abund<-pred.list$abund
marginals<-pred.list$marginals
marg.mean<-pred.list$marg.mean
lower.lim <- marginals[1] - 1000  # adjust later
upper.lim <- marginals[3] + 1000  # adjust later
#plot posterior mean and IC
G <- ggplot(data = abund, aes(x = N, y = mean)) +
geom_area(fill="orange",color="black") +
geom_vline(xintercept=marginals[1], linetype="dashed", color = "blue") +
geom_vline(xintercept=marginals[2], color = "red") +
geom_vline(xintercept=marginals[3], linetype="dashed", color = "blue") +
ggtitle("Estimated number of Individuals") +
scale_y_continuous(expand=c(0,0))+
theme_gdocs()+
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = "black"),
plot.background = element_blank()
)+
#theme_classic(base_size = 16) +
xlim(lower.lim, upper.lim)
# check range
# this is the posterior calculated by the model for the range
# (that we very roughly estimated for the non-informative prior)
#int.plot <- plot(lgcp.fit, "Intercept")
#spde.range <- spde.posterior(lgcp.fit, "spatial_spde", what = "range")
#plot(spde.range)
return(G)
}
#plot posterior mean and IC
G <- ggplot(data = abund, aes(x = N, y = mean)) +
geom_area(fill="orange",color="black") +
geom_vline(xintercept=marginals[1], linetype="dashed", color = "blue") +
geom_vline(xintercept=marginals[2], color = "red") +
geom_vline(xintercept=marginals[3], linetype="dashed", color = "blue") +
ggtitle("Estimated number of Individuals") +
scale_y_continuous(expand=c(0,0))+
theme_gdocs()+
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = "black"),
plot.background = element_blank()
)+
#theme_classic(base_size = 16) +
xlim(lower.lim, upper.lim)
plot.pop.priors(model.summaryout)
plot.pop.priors <- function(pred.list){
predicted<-pred.list$predicted
abund<-pred.list$abund
marginals<-pred.list$marginals
marg.mean<-pred.list$marg.mean
lower.lim <- marginals[1] - 1000  # adjust later
upper.lim <- marginals[3] + 1000  # adjust later
#plot posterior mean and IC
G <- ggplot(data = abund, aes(x = N, y = mean)) +
geom_area(fill="orange",color="black") +
geom_vline(xintercept=marginals[1], linetype="dashed", color = "blue") +
geom_vline(xintercept=marginals[2], color = "red") +
geom_vline(xintercept=marginals[3], linetype="dashed", color = "blue") +
ggtitle("Estimated number of Individuals") +
xlab("Population size")+
ylab("Mean")+
scale_y_continuous(expand=c(0,0))+
theme_gdocs()+
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = "black"),
plot.background = element_blank()
)+
#theme_classic(base_size = 16) +
xlim(lower.lim, upper.lim)
# check range
# this is the posterior calculated by the model for the range
# (that we very roughly estimated for the non-informative prior)
#int.plot <- plot(lgcp.fit, "Intercept")
#spde.range <- spde.posterior(lgcp.fit, "spatial_spde", what = "range")
#plot(spde.range)
return(G)
}
plot.pop.priors(model.summaryout)
predictions <- model.predictions(MESH,lcpe.model)
predictions$marg.mean
predictions$marginals
predictions$marginals[3]
predictions$marginals[1]
plot.pop.priors <- function(pred.list){
predicted<-pred.list$predicted
abund<-pred.list$abund
marginals<-pred.list$marginals
marg.mean<-pred.list$marg.mean
lower.lim <- marginals[1] - 1000  # adjust later
upper.lim <- marginals[3] + 1000  # adjust later
#plot posterior mean and IC
G <- ggplot(data = abund, aes(x = N, y = mean)) +
geom_area(fill="orange",color="black") +
geom_vline(xintercept=marginals[1], linetype="dashed", color = "blue") +
geom_vline(xintercept=marginals[2], color = "red") +
geom_vline(xintercept=marginals[3], linetype="dashed", color = "blue") +
ggtitle("Estimated number of Individuals") +
xlab("Population size")+
ylab("Mean")+
scale_y_continuous(expand=c(0,0))+
theme_gdocs()+
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = "black"),
plot.background = element_blank()
)+
#theme_classic(base_size = 16) +
xlim(lower.lim, upper.lim)
# check range
# this is the posterior calculated by the model for the range
# (that we very roughly estimated for the non-informative prior)
#int.plot <- plot(lgcp.fit, "Intercept")
#spde.range <- spde.posterior(lgcp.fit, "spatial_spde", what = "range")
#plot(spde.range)
return(G)
}
plot.pop.priors(predictions)
predictions$abund
MESH <- create.mesh(mask = mask,
MaxEdge = 4,
track=data.loaded$track,
obs.model = data.loaded$obs.model)
predictions$abund
predictions$marginals
source('D:/PROJECTS_CURRENT/SNH_Moray_Firth/SNH_Moray_Firth/scripts/helpers.R')
